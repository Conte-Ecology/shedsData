# ------------------------------
if ( nrow(cats)    != length(unique(cats$FEATUREID   )) ) { errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")}
if ( nrow(streams) != length(unique(streams$FEATUREID)) ) { errors[nrow(errors) + 1,] <- c("Duplicate streams exist."   )}
# Ensure all streams have a catchment
# -----------------------------------
if ( !all(streams$FEATUREID %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("Some streams do not have an associated catchment.")}
# Ensure all NextDownIDs are existing features
# --------------------------------------------
x <- cats$NextDownID[which(cats$NextDownID != -1)]
if( !all(x %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the catchments layer, some NextDownIDs do not exist as catchments.")}
y <- streams$NextDownID[which(streams$NextDownID != -1)]
if( !all(y %in% streams$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the streams layer, some NextDownIDs do not exist as stream segments.")}
# Make sure NextDownIDs didn't get altered incorrectly
# ----------------------------------------------------
a <- length(cats$NextDownID == -1)
b <- length(streams$NextDownID == -1)
d <- length(which(cats$Source == "Coastal Fill"))
if (a != b + d) { errors[nrow(errors) + 1,] <- c("The number of headwaters are mismatched.")}
# Join all tables together
# ------------------------
if( is.null(allCats)){
allCats <- cats}
else ( allCats <- rbind(allCats, cats))
if( is.null(allStreams)){
allStreams <- streams}
else ( allStreams <- rbind(allStreams, streams))
if ( nrow(errors) == 0 ){ errors[nrow(errors) + 1,] <- c("No errors found!")}
print(errors)
}
if ( length(unique(allCats$FEATUREID)) != nrow(allCats) ) { print( "Duplicate FEATUREIDs exist in the catchments layer.")}
if ( length(unique(allStreams$FEATUREID)) != nrow(allStreams) ) { print( "Duplicate FEATUREIDs exist in the streams layer.")}
errors
nrow(errors)
errors <- data.frame(paste0(X = numeric(0)))
errors
nrow(errors)
colnames(errors) <- paste0("Errors for hydrologic region ", hydroRegions[R])
nrow(errors)
if ( nrow(cats)    != length(unique(cats$FEATUREID   )) ) { errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")}
if ( nrow(streams) != length(unique(streams$FEATUREID)) ) { errors[nrow(errors) + 1,] <- c("Duplicate streams exist."   )}
# Ensure all streams have a catchment
# -----------------------------------
if ( !all(streams$FEATUREID %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("Some streams do not have an associated catchment.")}
nrow(errors)
errors
# Ensure all NextDownIDs are existing features
# --------------------------------------------
x <- cats$NextDownID[which(cats$NextDownID != -1)]
if( !all(x %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the catchments layer, some NextDownIDs do not exist as catchments.")}
errors
y <- streams$NextDownID[which(streams$NextDownID != -1)]
if( !all(y %in% streams$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the streams layer, some NextDownIDs do not exist as stream segments.")}
errors
# Make sure NextDownIDs didn't get altered incorrectly
# ----------------------------------------------------
a <- length(cats$NextDownID == -1)
b <- length(streams$NextDownID == -1)
d <- length(which(cats$Source == "Coastal Fill"))
if (a != b + d) { errors[nrow(errors) + 1,] <- c("The number of headwaters are mismatched.")}
errors
# Join all tables together
# ------------------------
if( is.null(allCats)){
allCats <- cats}
else ( allCats <- rbind(allCats, cats))
if( is.null(allStreams)){
allStreams <- streams}
else ( allStreams <- rbind(allStreams, streams))
if( is.null(allCats)){
allCats <- cats}
else ( allCats <- rbind(allCats, cats))
if ( nrow(errors) == 0 ){ errors[nrow(errors) + 1,] <- c("No errors found!")}
nrow(errors) == 0
nrow(errors)
errors
errors <- data.frame(paste0(X = numeric(0)))
colnames(errors) <- paste0("Errors for hydrologic region ", hydroRegions[R])
# Check for duplicate FEATUREIDs
# ------------------------------
if ( nrow(cats)    != length(unique(cats$FEATUREID   )) ) { errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")}
if ( nrow(streams) != length(unique(streams$FEATUREID)) ) { errors[nrow(errors) + 1,] <- c("Duplicate streams exist."   )}
# Ensure all streams have a catchment
# -----------------------------------
if ( !all(streams$FEATUREID %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("Some streams do not have an associated catchment.")}
# Ensure all NextDownIDs are existing features
# --------------------------------------------
x <- cats$NextDownID[which(cats$NextDownID != -1)]
if( !all(x %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the catchments layer, some NextDownIDs do not exist as catchments.")}
y <- streams$NextDownID[which(streams$NextDownID != -1)]
if( !all(y %in% streams$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the streams layer, some NextDownIDs do not exist as stream segments.")}
# Make sure NextDownIDs didn't get altered incorrectly
# ----------------------------------------------------
a <- length(cats$NextDownID == -1)
b <- length(streams$NextDownID == -1)
d <- length(which(cats$Source == "Coastal Fill"))
if (a != b + d) { errors[nrow(errors) + 1,] <- c("The number of headwaters are mismatched.")}
nrow(errors)
if ( nrow(errors) == 0 ){ errors[nrow(errors) + 1,] <- c("No errors found!")}
nrow(errors)
errors[1,] <- c("No errors found!")
str(errors)
errors <- data.frame(paste0(X = numeric(0)))
str(errors)
errors <- data.frame(paste0(X = character(0)))
str(errors)
colnames(errors) <- paste0("Errors for hydrologic region ", hydroRegions[R])
str(errors)
errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")
nodata <- data.frame(x= numeric(0), y= integer(0), z = character(0))
str(nodata)
?data.frame
nodata <- data.frame(x= numeric(0), y= integer(0), z = character(0), stringsAsFactors = FALSE)
str(nodata)
errors <- data.frame(paste0(X = character(0)), stringsAsFactors = FALSE)
str(errors)
colnames(errors) <- paste0("Errors for hydrologic region ", hydroRegions[R])
errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")
errors
str(errors)
# Load attributes tables
cats <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allCatchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allFlowlines", hydroRegions[R], ".dbf"))
errors <- data.frame(paste0(X = character(0)),
stringsAsFactors = FALSE)
colnames(errors) <- paste0("Errors for hydrologic region ", hydroRegions[R])
# Check for duplicate FEATUREIDs
# ------------------------------
if ( nrow(cats)    != length(unique(cats$FEATUREID   )) ) { errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")}
if ( nrow(streams) != length(unique(streams$FEATUREID)) ) { errors[nrow(errors) + 1,] <- c("Duplicate streams exist."   )}
?data.frame
# Ensure all streams have a catchment
# -----------------------------------
if ( !all(streams$FEATUREID %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("Some streams do not have an associated catchment.")}
# Ensure all NextDownIDs are existing features
# --------------------------------------------
x <- cats$NextDownID[which(cats$NextDownID != -1)]
if( !all(x %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the catchments layer, some NextDownIDs do not exist as catchments.")}
y <- streams$NextDownID[which(streams$NextDownID != -1)]
if( !all(y %in% streams$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the streams layer, some NextDownIDs do not exist as stream segments.")}
# Make sure NextDownIDs didn't get altered incorrectly
# ----------------------------------------------------
a <- length(cats$NextDownID == -1)
b <- length(streams$NextDownID == -1)
d <- length(which(cats$Source == "Coastal Fill"))
if (a != b + d) { errors[nrow(errors) + 1,] <- c("The number of headwaters are mismatched.")}
errors
if ( nrow(errors) == 0 ){ errors[1,] <- c("No errors found!")}
errors
print(errors)
rm(list = ls())
library(foreign)
library(dplyr)
# =============
# Define Inputs
# =============
hydroRegions <- c("01", "02", "03", "04", "05", "06")
#hucRegion <- "05"
baseDirectory <- "C:/KPONEIL/HRD/V2"
# ===============
# Quality Control
# ===============
allCats <- NULL
allStreams <- NULL
for ( R in seq_along(hydroRegions) ){
# Load attributes tables
cats <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allCatchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allFlowlines", hydroRegions[R], ".dbf"))
errors <- data.frame(paste0(X = character(0)),
stringsAsFactors = FALSE)
colnames(errors) <- paste0("Errors for Hydrologic Region ", hydroRegions[R])
# Check for duplicate FEATUREIDs
# ------------------------------
if ( nrow(cats)    != length(unique(cats$FEATUREID   )) ) { errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")}
if ( nrow(streams) != length(unique(streams$FEATUREID)) ) { errors[nrow(errors) + 1,] <- c("Duplicate streams exist."   )}
?data.frame
# Ensure all streams have a catchment
# -----------------------------------
if ( !all(streams$FEATUREID %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("Some streams do not have an associated catchment.")}
# Ensure all NextDownIDs are existing features
# --------------------------------------------
x <- cats$NextDownID[which(cats$NextDownID != -1)]
if( !all(x %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the catchments layer, some NextDownIDs do not exist as catchments.")}
y <- streams$NextDownID[which(streams$NextDownID != -1)]
if( !all(y %in% streams$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the streams layer, some NextDownIDs do not exist as stream segments.")}
# Make sure NextDownIDs didn't get altered incorrectly
# ----------------------------------------------------
a <- length(cats$NextDownID == -1)
b <- length(streams$NextDownID == -1)
d <- length(which(cats$Source == "Coastal Fill"))
if (a != b + d) { errors[nrow(errors) + 1,] <- c("The number of headwaters are mismatched.")}
# Join all tables together
# ------------------------
if( is.null(allCats)){
allCats <- cats}
else ( allCats <- rbind(allCats, cats))
if( is.null(allStreams)){
allStreams <- streams}
else ( allStreams <- rbind(allStreams, streams))
if ( nrow(errors) == 0 ){ errors[1,] <- c("No errors found!")}
print(errors)
}
if ( length(unique(allCats$FEATUREID)) != nrow(allCats) ) { print( "Duplicate FEATUREIDs exist in the catchments layer.")}
if ( length(unique(allStreams$FEATUREID)) != nrow(allStreams) ) { print( "Duplicate FEATUREIDs exist in the streams layer.")}
rm(list = ls())
library(foreign)
library(dplyr)
# =============
# Define Inputs
# =============
baseDirectory <- "C:/KPONEIL/HRD/V2"
hydroRegions <- c("01", "02", "03", "04", "05", "06")
run <- 1
# ===============
# Quality Control
# ===============
allCats <- NULL
allStreams <- NULL
# Loop through all hydrologic regions
for ( R in seq_along(hydroRegions) ){
if ( run == 1 ){
# Load attributes tables
cats <- read.dbf(paste0(baseDirectory, "/products/NHDH", hydroRegions[R], "/allCatchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allFlowlines", hydroRegions[R], ".dbf"))
}
if ( run == 2 ){
# Load attributes tables
cats <-    read.dbf(paste0(baseDirectory, "/gisFiles/shapefiles/Catchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/gisFiles/shapefiles/Flowlines",  hydroRegions[R], ".dbf"))
}
errors <- data.frame(paste0(X = character(0)),
stringsAsFactors = FALSE)
colnames(errors) <- paste0("Errors for Hydrologic Region ", hydroRegions[R])
# Check for duplicate FEATUREIDs
# ------------------------------
if ( nrow(cats)    != length(unique(cats$FEATUREID   )) ) { errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")}
if ( nrow(streams) != length(unique(streams$FEATUREID)) ) { errors[nrow(errors) + 1,] <- c("Duplicate streams exist."   )}
?data.frame
# Ensure all streams have a catchment
# -----------------------------------
if ( !all(streams$FEATUREID %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("Some streams do not have an associated catchment.")}
# Ensure all NextDownIDs are existing features
# --------------------------------------------
x <- cats$NextDownID[which(cats$NextDownID != -1)]
if( !all(x %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the catchments layer, some NextDownIDs do not exist as catchments.")}
y <- streams$NextDownID[which(streams$NextDownID != -1)]
if( !all(y %in% streams$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the streams layer, some NextDownIDs do not exist as stream segments.")}
# Make sure NextDownIDs didn't get altered incorrectly
# ----------------------------------------------------
a <- length(cats$NextDownID == -1)
b <- length(streams$NextDownID == -1)
d <- length(which(cats$Source == "Coastal Fill"))
if (a != b + d) { errors[nrow(errors) + 1,] <- c("The number of headwaters are mismatched.")}
# Join all tables together
# ------------------------
if( is.null(allCats)){
allCats <- cats}
else ( allCats <- rbind(allCats, cats))
if( is.null(allStreams)){
allStreams <- streams}
else ( allStreams <- rbind(allStreams, streams))
if ( nrow(errors) == 0 ){ errors[1,] <- c("No errors found!")}
print(errors)
}
if(length(hydroRegions) > 1){
# Check if duplicates exist between hydrologic regions
if ( length(unique(allCats$FEATUREID)) != nrow(allCats) ) { print( "Duplicate FEATUREIDs exist in the catchments layer.")}
if ( length(unique(allStreams$FEATUREID)) != nrow(allStreams) ) { print( "Duplicate FEATUREIDs exist in the streams layer.")}
}
rm(list = ls())
library(foreign)
library(dplyr)
# =============
# Define Inputs
# =============
baseDirectory <- "C:/KPONEIL/HRD/V2"
hydroRegions <- c("01", "02", "03", "04", "05", "06")
run <- 1
# ===============
# Quality Control
# ===============
allCats <- NULL
allStreams <- NULL
# Loop through all hydrologic regions
for ( R in seq_along(hydroRegions) ){
if ( run == 1 ){
# Load attributes tables
cats <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allCatchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allFlowlines", hydroRegions[R], ".dbf"))
}
if ( run == 2 ){
# Load attributes tables
cats <-    read.dbf(paste0(baseDirectory, "/products/shapefiles/Catchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/products/shapefiles/Flowlines",  hydroRegions[R], ".dbf"))
}
errors <- data.frame(paste0(X = character(0)),
stringsAsFactors = FALSE)
colnames(errors) <- paste0("Errors for Hydrologic Region ", hydroRegions[R])
# Check for duplicate FEATUREIDs
# ------------------------------
if ( nrow(cats)    != length(unique(cats$FEATUREID   )) ) { errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")}
if ( nrow(streams) != length(unique(streams$FEATUREID)) ) { errors[nrow(errors) + 1,] <- c("Duplicate streams exist."   )}
?data.frame
# Ensure all streams have a catchment
# -----------------------------------
if ( !all(streams$FEATUREID %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("Some streams do not have an associated catchment.")}
# Ensure all NextDownIDs are existing features
# --------------------------------------------
x <- cats$NextDownID[which(cats$NextDownID != -1)]
if( !all(x %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the catchments layer, some NextDownIDs do not exist as catchments.")}
y <- streams$NextDownID[which(streams$NextDownID != -1)]
if( !all(y %in% streams$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the streams layer, some NextDownIDs do not exist as stream segments.")}
# Make sure NextDownIDs didn't get altered incorrectly
# ----------------------------------------------------
a <- length(cats$NextDownID == -1)
b <- length(streams$NextDownID == -1)
d <- length(which(cats$Source == "Coastal Fill"))
if (a != b + d) { errors[nrow(errors) + 1,] <- c("The number of headwaters are mismatched.")}
# Join all tables together
# ------------------------
if( is.null(allCats)){
allCats <- cats}
else ( allCats <- rbind(allCats, cats))
if( is.null(allStreams)){
allStreams <- streams}
else ( allStreams <- rbind(allStreams, streams))
if ( nrow(errors) == 0 ){ errors[1,] <- c("No errors found!")}
print(errors)
}
if(length(hydroRegions) > 1){
# Check if duplicates exist between hydrologic regions
if ( length(unique(allCats$FEATUREID)) != nrow(allCats) ) { print( "Duplicate FEATUREIDs exist in the catchments layer.")}
if ( length(unique(allStreams$FEATUREID)) != nrow(allStreams) ) { print( "Duplicate FEATUREIDs exist in the streams layer.")}
}
rm(list = ls())
library(foreign)
library(dplyr)
# =============
# Define Inputs
# =============
baseDirectory <- "C:/KPONEIL/HRD/V2"
hydroRegions <- c("01", "02", "03", "04", "05", "06")
run <- 2
# ===============
# Quality Control
# ===============
allCats <- NULL
allStreams <- NULL
# Loop through all hydrologic regions
for ( R in seq_along(hydroRegions) ){
if ( run == 1 ){
# Load attributes tables
cats <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allCatchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allFlowlines", hydroRegions[R], ".dbf"))
}
if ( run == 2 ){
# Load attributes tables
cats <-    read.dbf(paste0(baseDirectory, "/products/shapefiles/Catchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/products/shapefiles/Flowlines",  hydroRegions[R], ".dbf"))
}
errors <- data.frame(paste0(X = character(0)),
stringsAsFactors = FALSE)
colnames(errors) <- paste0("Errors for Hydrologic Region ", hydroRegions[R])
# Check for duplicate FEATUREIDs
# ------------------------------
if ( nrow(cats)    != length(unique(cats$FEATUREID   )) ) { errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")}
if ( nrow(streams) != length(unique(streams$FEATUREID)) ) { errors[nrow(errors) + 1,] <- c("Duplicate streams exist."   )}
?data.frame
# Ensure all streams have a catchment
# -----------------------------------
if ( !all(streams$FEATUREID %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("Some streams do not have an associated catchment.")}
# Ensure all NextDownIDs are existing features
# --------------------------------------------
x <- cats$NextDownID[which(cats$NextDownID != -1)]
if( !all(x %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the catchments layer, some NextDownIDs do not exist as catchments.")}
y <- streams$NextDownID[which(streams$NextDownID != -1)]
if( !all(y %in% streams$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the streams layer, some NextDownIDs do not exist as stream segments.")}
# Make sure NextDownIDs didn't get altered incorrectly
# ----------------------------------------------------
a <- length(cats$NextDownID == -1)
b <- length(streams$NextDownID == -1)
d <- length(which(cats$Source == "Coastal Fill"))
if (a != b + d) { errors[nrow(errors) + 1,] <- c("The number of headwaters are mismatched.")}
# Join all tables together
# ------------------------
if( is.null(allCats)){
allCats <- cats}
else ( allCats <- rbind(allCats, cats))
if( is.null(allStreams)){
allStreams <- streams}
else ( allStreams <- rbind(allStreams, streams))
if ( nrow(errors) == 0 ){ errors[1,] <- c("No errors found!")}
print(errors)
}
if(length(hydroRegions) > 1){
# Check if duplicates exist between hydrologic regions
if ( length(unique(allCats$FEATUREID)) != nrow(allCats) ) { print( "Duplicate FEATUREIDs exist in the catchments layer.")}
if ( length(unique(allStreams$FEATUREID)) != nrow(allStreams) ) { print( "Duplicate FEATUREIDs exist in the streams layer.")}
}
length(hydroRegions) > 1
length(unique(allCats$FEATUREID)) != nrow(allCats)
length(unique(allStreams$FEATUREID)) != nrow(allStreams)
R = 1
cats <-    read.dbf(paste0(baseDirectory, "/products/shapefiles/Catchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/products/shapefiles/Flowlines",  hydroRegions[R], ".dbf"))
x <- cats$NextDownID[which(cats$NextDownID != -1)]
all(x %in% cats$FEATUREID)
which(x %in% cats$FEATUREID)
which(x %in% cats$FEATUREID == FALSE)
x[10750,]
x[10750]
rm(list = ls())
library(foreign)
library(dplyr)
# =============
# Define Inputs
# =============
baseDirectory <- "C:/KPONEIL/HRD/V2"
hydroRegions <- c("01", "02", "03", "04", "05", "06")
run <- 2
# ===============
# Quality Control
# ===============
allCats <- NULL
allStreams <- NULL
# Loop through all hydrologic regions
for ( R in seq_along(hydroRegions) ){
if ( run == 1 ){
# Load attributes tables
cats <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allCatchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/gisFiles/NHDH", hydroRegions[R], "/allFlowlines", hydroRegions[R], ".dbf"))
}
if ( run == 2 ){
# Load attributes tables
cats <-    read.dbf(paste0(baseDirectory, "/products/shapefiles/Catchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/products/shapefiles/Flowlines",  hydroRegions[R], ".dbf"))
}
errors <- data.frame(paste0(X = character(0)),
stringsAsFactors = FALSE)
colnames(errors) <- paste0("Errors for Hydrologic Region ", hydroRegions[R])
# Check for duplicate FEATUREIDs
# ------------------------------
if ( nrow(cats)    != length(unique(cats$FEATUREID   )) ) { errors[nrow(errors) + 1,] <- c("Duplicate catchments exist.")}
if ( nrow(streams) != length(unique(streams$FEATUREID)) ) { errors[nrow(errors) + 1,] <- c("Duplicate streams exist."   )}
?data.frame
# Ensure all streams have a catchment
# -----------------------------------
if ( !all(streams$FEATUREID %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("Some streams do not have an associated catchment.")}
# Ensure all NextDownIDs are existing features
# --------------------------------------------
# Catchments
x <- cats$NextDownID[which(cats$NextDownID != -1)]
if( !all(x %in% cats$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the catchments layer, some NextDownIDs do not exist as catchments.")}
# Flowlines
y <- streams$NextDownID[which(streams$NextDownID != -1)]
if( !all(y %in% streams$FEATUREID) ) { errors[nrow(errors) + 1,] <- c("In the streams layer, some NextDownIDs do not exist as stream segments.")}
# Make sure NextDownIDs didn't get altered incorrectly
# ----------------------------------------------------
a <- length(cats$NextDownID == -1)
b <- length(streams$NextDownID == -1)
d <- length(which(cats$Source == "Coastal Fill"))
if (a != b + d) { errors[nrow(errors) + 1,] <- c("The number of headwaters are mismatched.")}
# Join all tables together
# ------------------------
if( is.null(allCats)){
allCats <- cats}
else ( allCats <- rbind(allCats, cats))
if( is.null(allStreams)){
allStreams <- streams}
else ( allStreams <- rbind(allStreams, streams))
if ( nrow(errors) == 0 ){ errors[1,] <- c("No errors found!")}
print(errors)
}
if(length(hydroRegions) > 1){
# Check if duplicates exist between hydrologic regions
if ( length(unique(allCats$FEATUREID)) != nrow(allCats) ) { print( "Duplicate FEATUREIDs exist in the catchments layer.")}
if ( length(unique(allStreams$FEATUREID)) != nrow(allStreams) ) { print( "Duplicate FEATUREIDs exist in the streams layer.")}
}
rm(list = ls())
library(foreign)
library(dplyr)
# =============
# Define Inputs
# =============
baseDirectory <- "C:/KPONEIL/HRD/V2"
hydroRegions <- c("01", "02", "03", "04", "05", "06")
# ===============
# Calculate Stats
# ===============
stats <- as.data.frame(matrix(NA, ncol = 7, nrow = 6))
names(stats) <- c("Hydrologic Region",
"Number of Catchments",
"Mean Catchment Area",
"Median Catchment Area",
"Number of Flowlines",
"Mean Flowline Length",
"Median Flowline Length")
# Loop through all hydrologic regions
for ( R in seq_along(hydroRegions) ){
# Load attributes tables
cats <-    read.dbf(paste0(baseDirectory, "/products/shapefiles/Catchments", hydroRegions[R], ".dbf"))
streams <- read.dbf(paste0(baseDirectory, "/products/shapefiles/smoothedFlowlines",  hydroRegions[R], ".dbf"))
stats[R, 1] <- hydroRegions[R]
stats[R, 2] <- nrow(cats)
stats[R, 3] <- round(mean(cats$AreaSqKM), digits = 2)
stats[R, 4] <- round(median(cats$AreaSqKM), digits = 2)
stats[R, 5] <- nrow(streams)
stats[R, 6] <- round(mean(streams$LengthKM), digits = 2)
stats[R, 7] <- round(median(streams$LengthKM), digits = 2)
}
write.csv(stats,
file = paste0(baseDirectory, "/report/layerStats.csv"),
row.names = F)
